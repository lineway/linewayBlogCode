---
title: python网络编程----UDP（2）
date: 2018-12-31 17:25:21
tags: python
categories: 编程学习
---

## 混杂客户端和垃圾回复

上一篇 [UDP简介](https://lineway.github.io/2018/12/31/python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-UDP/)介绍了一个简单的 UDP服务端和客户端实现，这是一个简单的实现，这种方式实现的客户端程序是十分危险的。尽管`recvfrom()`返回了传入的数据报地址，但是代码没有检查该数据报的源地址，即客户端没有检查该数据报是否由客户端发出。

假设现在有一个攻击者，在服务端返回数据报之前将伪造的数据报发送给该客户端，那么客户端就会认为伪造的数据报来源于真是的服务端。像这样不考虑地址是否正确，接收并处理所有收到的数据包的网络监听客户端在技术上叫做`混杂(promiscuous)客户端`。这种客户端有其适用的场景，但是在当前情况下，这是一个问题。

一般而言，使用好的加密方法能保证程序与正确的服务器进行通信。但是也可以通过两个简单方案解决这类问题：

- 设计或使用在请求中包含唯一标识符或请求ID的协议；
- 检查响应数据包的地址与请求数据包的地址是否相同；

在使用唯一标识符这种方法的时候，可以在响应中重复特定请求的唯一标识符或请求ID，这样，攻击者需要构造正确的ID才能进行攻击。使用第二种方法，python可以使用`==`来比较元组，也可以使用`connect()`来阻止其他地址向客户端发送数据包。

## 不可靠性、阻塞和超时

使用同一台机器运行服务端和客户端时，数据包实质上是不可能丢失的，这与实际的UDP协议是有出入的。实际上，使用UDP协议，客户端需要面对随机可能的服务端丢包现象。

首先，UDP的不可靠性意味着客户端必须在一个循环内发送请求。对于这个请求的响应，客户端可以选择永远等待，也可以通过设置等待时长，在超时之后重新发送一个请求。虽然设置等待时长的这种方式在某种程度上会浪费一些服务器的时间（如第一个请求即将传至客户端，而第二个请求导致服务器做一些不必要的重复操作）。但是，客户端仍然需要在设定的等待周期重新发送请求，否则客户端会一直等待下去。如果一个调用等待网络操作完成，那么可以说这个调用阻塞(block)了调用方。前面描述的客户端一直等待服务端的响应，这个过程就存在着阻塞。

## 连接套接字

关于绑定，前面提到我们可以使用显式的`bind()`和隐式的方法。显式的`bind()`调用发生在服务端，用来指定服务器要使用的IP地址和端口；隐式绑定发生在客户端，操作系统随机分配一个临时端口。当然，套接字操作`connect()`也可以进行绑定操作。区别在于，如果使用`sendto()`，那么每次向服务器发送信息时，都必须显式的给出服务器的IP地址和端口：

```python
sock = socket.scoket(socket.AF_INET, socket.SOCK_DGRAM)
sock.sendto(data, address)
```

如果使用`connect()`调用，则可以直接调用`send()`方法，而无需每次发送数据都重复给出服务器地址。并且，在使用`connect()`之后，前面提到的客户端混杂性问题也会得到解决，一旦配置了`connect()`，那么操作系统在发现传入数据包的返回地址与已连接的地址不同，就会将该数据包丢弃：

```python
# client
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
sock.connect((hostname, port))
```

由此可知，如果我们需要编写对响应数据包返回地址进行校验的UDP客户端，可以使用两种方法：

- 使用`sendto()`指定每个数据包的目标地址，然后使用`recvfrom()`接收响应，并检查响应数据包的返回地址；

```python
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
text = "The time is {}".format(datetime.now())
data = text.encode("ascii")
sock.sendto(data, ("127.0.0.1", port))
print("The OS assigned me the address {}".format(sock.getsockname()))
data, address = sock.recvfrom(MAX_BYTES)
```

- 在创建套接字以后使用`connect()`将其与目标地址连接，然后使用`send()`和`recv()`进行通信，操作系统将不需要的数据包过滤掉。这种做法值支持同时与一台服务器交互的情况，因为同一套接字重复运行`connect()`会将之前的地址覆盖掉。

```python
sock.connect((hostname, port))
sock.send(data)
```



关于`connect()`调用，需要明确两点：

- 使用`connect()`连接UDP套接字，只是简单的将连接的地址写入操作系统内存，方便`send()`和`recv()`方法调用；
- 使用`connect()`并不能够确保安全，攻击者可以伪造出拥有服务器返回地址的数据包，这种使用另一台计算机的返回地址发送数据包的行为叫做`电子欺诈（spoofing）`。

## 请求ID

请求ID存在的意义在于，将请求与响应对应起来。这样可以解决客户端重复发送请求造成的重复问题以及网络结构的冗余造成的重复问题。同样，请求ID的建立，就如之前提到的那样，可以在攻击者无法获取我们的数据包时对电子欺诈起到一定的震慑作用。

请求ID的构造可以在发送每个请求的时候添加一个序列号，在服务端接收到请求后，只需要将序列号复制到响应中即可。使用这种方式，就可以实现一个简单的请求ID过程。

